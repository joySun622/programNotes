[Toc]

### 为什么要进行版本控制？

答：版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。

1）记录文件内容变化；

2）方便查阅特定版本修订情况；

3）方便查阅文件变化细节，方便排查文件问题，查找到问题出现原因；

4）当某个版本出现问题时，可及时回退文件；



### 版本控制系统的发展

1. 本地版本控制系统；

2. 集中式版本控制系统(Centralized Version Control Systems，简称 CVCS)；

3. 分布式版本控制系统(Distributed Version Control System，简称 DVCS)；

以上三种版本控制系统差异：

| 版本系统      差异 | 原理                                                         | 优缺点                                                       | 范例                                                         |
| ------------------ | :----------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 本地版本控制系统   | 大多都是采用某种简单的数据库来记录文件的历次更新差异。       | 优点：初期版本系统，适合少量的简单的文件版本控制     <br />缺点：1. 无法进行开发者协同工作     2. 整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。 | RCS 的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。 |
| 集中式版本控制系统 | 有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新 | 优点：1.  相对本地版本控制系统，可方便查看项目其他成员的工作内容；    <br /> 2. 方便管理员控制其他开发者权限；           <br />缺点：1. 当中央服务器的单点故障时，无法协同工作；     2. 当中央服务器磁盘损坏，又没有做恰当备份，将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照 | CVS、Subversion 以及 Perforce                                |
| 分布式版本控制系统 | 客户端并不只提取最新版本的文件快照，  而是把代码仓库完整地镜像下来，包括完整的历史记录。 | 优点：1.  任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复；    <br /> 2. 可以指定和若干不同的远端代码仓库进行交互     <br />缺点： | Git、Mercurial、Bazaar  以及 Darcs 等                        |

### GIT 目标

- 速度
- 简单的设计
- 对非线性开发模式的强力支持（允许成千上万个并行开发的分支）
- 完全分布式
- 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）

### GIT特点

1. **存储数据的方式：直接记录快照，而非差异比较；**

   > Git 更像是把数据看作是对小型文件系统的一系列快照。 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 **快照流**。
   >
   > ![Git 存储项目随时间改变的快照。](images/snapshots.png)

   > 其它大部分系统以文件变更列表的方式存储信息，这类系统（CVS、Subversion、Perforce、Bazaar 等等） 将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 （它们通常称作 **基于差异（delta-based）** 的版本控制）。
   >
   > ![存储每个文件与初始版本的差异。](images/deltas.png)


2. **近乎所有操作都是本地执行**

> 在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。

3. **Git 保证完整性**

> Git 中所有的数据在存储前都计算校验和[^1]，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。
>
> Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来。 
>
> 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。


4. **Git 一般只添加数据**

   > 执行的 Git 操作，几乎只往 Git 数据库中 **添加** 数据

5. **Git 文件三种状态**

   >  **已提交（committed）**、**已修改（modified）** 和 **已暂存（staged）**。
   >
   > - 已修改表示修改了文件，但还没保存到数据库中。
   > - 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。
   > - 已提交表示数据已经安全地保存在本地数据库中。

   **Git 项目三个阶段**

   ![工作区、暂存区以及 Git 目录。](images/areas.png)

   > 工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。
   >
   > 暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。
   >
   > Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。

   #### 基本的 Git 工作流程如下：

   1. 在工作区中修改文件。
   2. 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。
   3. 提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。

   > 如果 Git 目录中保存着特定版本的文件，就属于 **已提交** 状态。 如果文件已修改并放入暂存区，就属于 **已暂存** 状态。 如果自上次检出后，作了修改但还没有放到暂存区域，就是 **已修改** 状态。

   ###  获取 Git 仓库

   > 通常有两种获取 Git 项目仓库的方式：
   > 1. 将尚未进行版本控制的本地目录转换为 Git 仓库；
   > 2. 从其它服务器 **克隆** 一个已存在的 Git 仓库。
   > 两种方式都会在你的本地机器上得到一个工作就绪的 Git 仓库。

   1. 在已存在目录中初始化仓库

      > ```console
      > // 进如需Git版本控制的项目目录,执行以下命令
      > $ git init
      > ```
      >
      > 该命令将创建一个名为 `.git` 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。
      >
      > 可以通过 `git add` 命令来指定所需的文件来进行追踪，然后执行 `git commit`

   2. 克隆现有的仓库

      > ```console
      > // 在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹
      > $ git clone https://github.com/libgit2/libgit2
      > //克隆远程仓库的时候，自定义本地仓库的名字mylibgit
      > $ git clone https://github.com/libgit2/libgit2 mylibgit
      > 
      > Git 支持多种数据传输协议。 上面的例子使用的是 https:// 协议，不过你也可以使用 git:// 协议或者使用 SSH 传输协议，比如 user@server:path/to/repo.git 。
      > ```
      >
      > Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 `git clone` 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下
      >
      > 来。

### GIT分支

   1. **Git保存数据的方式与特点**

> - Git 中所有的数据在存储前都计算校验和[^1]，然后以校验和来引用，Git中使用 SHA-1 哈希算法计算校验和;
> - Git 保存的不是文件的变化或者差异，而是一系列不同时刻的 **快照**;
> - **暂存操作**会为每一个文件计算校验和（使用我们在 [起步](https://git-scm.com/book/zh/v2/ch00/ch01-getting-started) 中提到的 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库[^2]中 （Git 使用 *blob* 对象来保存它们），最终将校验和加入到暂存区域等待提交：
> - 在进行提交操作时，Git 会保存一个提交对象（commit object）;

2. **Git暂存操作数据变化**

> - 为每一个文件使用SHA-1哈希算法计算校验和；
> - 使用blob对象保存当前版本的文件快照到Git仓库[^2]中；
> - 将校验和加入到暂存区域等待提交；

3. **提交对象包含的内容**

> - 一个指向暂存内容快照的指针
> - 作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象

4. **当使用 `git commit` 进行提交操作时，数据变化**

> 1) Git 会先计算每一个子目录的校验和,在 Git 仓库[^2]中这些校验和保存为树对象;
>
> 2) Git 创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针
>
> 3）此时Git 仓库中有以下对象：保存版本文件快照的 *blob* 对象、一个 **树** 对象 （记录着目录结构和 blob 对象索引）以及一个 **提交** 对象（包含着指向前述树对象的指针和所有提交信息）；
>
> ![首次提交对象及其树结构。](images/commit-and-tree.png)
>
> 4）做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针；
>
> ![提交对象及其父对象。](images/commits-and-parents.png)

#### 分支相关操作

1. **分支含义**

> Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 `master`。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 `master` 分支。 `master` 分支会在每次提交时自动向前移动。
>
> Git 的 `master` 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 `git init` 命令默认创建它，并且大多数人都懒得去改动它。
>
> 由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？



> ![分支及其提交历史。](images/branch-and-history.png)

2. **分支创建**

> 创建分支只是为你创建了一个可以移动的新的指针
>
> `$ git branch testing  //创建testing 分支`
>
>  `git checkout -b <newbranchname> //创建一个新分支后立即切换过去  ` 
>
> 这会在当前所在的提交对象上创建一个指针。 `git branch` 命令仅仅 **创建** 一个新分支，并不会自动切换到新分支中去
>
> ![两个指向相同提交历史的分支。](images/two-branches.png)

3. **当前分支的确认**

> 在 Git 中，它有一个名为 `HEAD` 的特殊指针,它是一个指针，指向当前所在的本地分支（译注：将 `HEAD` 想象为当前分支的别名）,HEAD 随着提交操作自动向前移动
>
> ![HEAD 指向当前所在的分支。](images/head-to-master.png)

4. **怎样查看各个分支当前所指的对象**

> 简单地使用 `git log` 命令查看各个分支当前所指的对象,提供这一功能的参数是 `--decorate`。
>
> 如下所示：当前 `master` 和 `testing` 分支均指向校验和以 `f30ab` 开头的提交对象
>
> ```console
> $ git log --oneline --decorate
> f30ab (HEAD -> master, testing) add feature #32 - ability to add new formats to the central interface
> 34ac2 Fixed bug #1328 - stack overflow under certain conditions
> 98ca9 The initial commit of my project
> ```

5. **分支切换**

> 分支切换会改变你工作目录中的文件
>
> 在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。

> 要切换到一个已存在的分支，你需要使用 `git checkout` 命令。 我们现在切换到新创建的 `testing` 分支去：
>
> ```console
> $ git checkout testing
> ```
>
> 这样 `HEAD` 就指向 `testing` 分支了。
>
> ![HEAD 指向当前所在的分支。](images/head-to-testing.png)
>
> 如果在当前分支上修改文件，并执行提交命令，`testing` 分支向前移动了，但是 `master` 分支却没有，它仍然指向运行 `git checkout` 时所指的对象。
>
> ![HEAD 分支随着提交操作自动向前移动。](images/advance-testing.png)

6.  **项目分叉历史**

> 两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。
>
> ![项目分叉历史。](images/advance-master.png)
>
> ```console
> //运行 git log --oneline --decorate --graph --all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。
> 
> $ git log --oneline --decorate --graph --all
> * c2b9e (HEAD, master) made other changes
> | * 87ab2 (testing) made a change
> |/
> * f30ab add feature #32 - ability to add new formats to the
> * 34ac2 fixed bug #1328 - stack overflow under certain conditions
> * 98ca9 initial commit of my project
> ```

#### 分支应用场景

- 场景1：如下图，有master,hotfix,iss53三个分支，且每分支的所处位置如下

  ![基于 `master` 分支的紧急问题分支（hotfix branch）。](images/basic-branching-4.png)

**问题：**

1. **快进：`hotfix` 分支合并回你的 `master` 分支**

   >  执行命令如下：
   >
   > ```console
   > $ git checkout master
   > $ git merge hotfix
   > Updating f42c576..3a0874c
   > Fast-forward  
   >  index.html | 2 ++
   >  1 file changed, 2 insertions(+)
   >  //当分支已无作用，删除分支
   >  $ git branch -d hotfix
   > Deleted branch hotfix (3a0874c).
   > ```

> 注意【快进（fast-forward）】当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。

2. **合并提交：合并 `iss53` 分支到 `master` 分支**

   ![一次典型合并中所用到的三个快照。](images/basic-merging-1.png)
   
   > ```console
   > $ git checkout master
   > Switched to branch 'master'
   > $ git merge iss53
   > Merge made by the 'recursive' strategy.
   > index.html |    1 +
   > 1 file changed, 1 insertion(+)
   > //合并后删除分支
   > $ git branch -d iss53
   > ```
   >

>  在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，`master` 分支所在提交并不是 `iss53` 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（`C4` 和 `C5`）以及这两个分支的公共祖先（`C2`），做一个简单的**三方合并**。
>
> 和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次**合并提交**，它的特别之处在于他有不止一个父提交。
>
> ![一个合并提交。](images/basic-merging-2.png)

3. **遇到冲突时的分支合并**

> 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。
>
> 简单解决办法：
>
> a. 使用 `git status` 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件,任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。
>
> Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：
>
> ```html
> <<<<<<< HEAD:index.html
> <div id="footer">contact : email.support@github.com</div>
> =======
> <div id="footer">
>  please contact us at support@github.com
> </div>
> >>>>>>> iss53:index.html
> ```
>
> b. 这表示 `HEAD` 所指示的版本（也就是你的 `master` 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（`=======` 的上半部分），而 `iss53` 分支所指示的版本在 `=======` 的下半部分。 为了解决冲突，你必须选择使用由 `=======` 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突：
>
> ```html
> <div id="footer">
> please contact us at email.support@github.com
> </div>
> ```
>
> 上述的冲突解决方案仅保留了其中一个分支的修改，并且 `<<<<<<<` , `=======` , 和 `>>>>>>>` 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 `git add` 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。
>
> 也可使用运行 `git mergetool` Git提供合并图形化工具进行合并。
>
> 当合并没有冲突后，输入 `git commit` 来完成

**解决方案扩展：**

> 1. **中断一次合并**： `git merge --abort` 来简单地退出合并;该选项会尝试恢复到你运行合并前的状态。 但当运行命令前，在工作目录中有未储藏、未提交的修改时它不能完美处理，除此之外它都工作地很好。
>
> 2. 解决文件冲突后，使用 `git add` 命令来将其标记为冲突已解决；
>
> 3. 出于某些原因你想要重来一次，也可以运行 `git reset --hard HEAD` 回到上一次提交的状态。 请牢记此时任何未提交的工作都会丢失，所以请确认你不需要保留任何改动。
>
> 4. **冲突与空白有关**，如：团队中的某个人可能不小心重新格式化空格为制表符或者相反的操作，使用 `-Xignore-all-space` 或 `-Xignore-space-change` 选项。 第一个选项在比较行时 **完全忽略** 空白修改，第二个选项将一个空白符与多个连续的空白字符视作等价的;注意：使用 `ignore-space-change` 进行合并操作后，有几行是 DOS 行尾的文件，从而使提交内容混乱；
>
>    ```console
>    $ git merge -Xignore-space-change whitespace
>    Auto-merging hello.rb
>    Merge made by the 'recursive' strategy.
>     hello.rb | 2 +-
>     1 file changed, 1 insertion(+), 1 deletion(-)
>    ```
> 
>  

#### 分支类型

- **长期分支**

> 建立多个分支，以其中一个分支作为稳定分支，当其他分支具有一定稳定性后，合并到具有更高稳定性的分支中。
>
> 使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时
>
> ![趋于稳定分支的工作流（“silo”）视图。](images/lr-branches-2.png)

- **主题分支**

> 主题分支对任何规模的项目都适用。 主题分支是一种短期分支，它被用来实现单一特性或其相关工作。
>
> 根据主题建立短期分支，当短期分支的工作完成后，合并到master分支中，删除建立的短期分支

#### 远程分支

> 远程引用是对远程仓库的引用（指针），包括分支、标签等等。
>
> 远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。

**范例**

>  假设你的网络里有一个在 `git.ourcompany.com` 的 Git 服务器。 如果你从这里克隆，Git 的 `clone` 命令会为你自动将其命名为 `origin`，拉取它的所有数据， 创建一个指向它的 `master` 分支的指针，并且在本地将其命名为 `origin/master`。 Git 也会给你一个与 origin 的 `master` 分支在指向同一个地方的本地 `master` 分支，这样你就有工作的基础。
>
> ![克隆之后的服务器与本地仓库。](images/remote-branches-1.png)



> 远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 `git init` 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 `git clone` 时默认的远程仓库名字。 如果你运行 `git clone -o booyah`，那么你默认的远程分支名字将会是 `booyah/master`。
>
> 如果你在本地的 `master` 分支做了一些工作，在同一段时间内有其他人推送提交到 `git.ourcompany.com` 并且更新了它的 `master` 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 `origin` 服务器连接（并拉取数据），你的 `origin/master` 指针就不会移动。
>
> 如果要与给定的远程仓库同步数据，运行 `git fetch <remote>` 命令（在本例中为 `git fetch origin`）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 `git.ourcompany.com`）， 从中抓取本地没有的数据，并且更新本地数据库，移动 `origin/master` 指针到更新之后的位置。
>
> ![`git fetch` 更新你的远程仓库引用。](images/remote-branches-3.png)

#### 变基

> **变基（rebase）**:使用 `rebase` 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。
>
> 要用它得遵守一条准则：
>
> **如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。**
>
> 它的原理是首先找到这两个分支（即当前分支 `experiment`、变基操作的目标基底分支 `master`） 的最近共同祖先 `C2`，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 `C3`, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同）
>
> ```console
> $ git checkout experiment
> $ git rebase master
> First, rewinding head to replay your work on top of it...
> Applying: added staged command
> ```
>
> ![将 `C4` 中的修改变基到 `C3` 上。](images/basic-rebase-3.png)
>
> ```console
> $ git checkout master
> $ git merge experiment
> ```
>
> ![`master` 分支的快进合并。](images/basic-rebase-4.png)

- **更复杂的变基过程**

> ```console
> $ git rebase --onto master server client
> ```
>
> 以上命令的意思是：“取出 `client` 分支，找出它从 `server` 分支分歧之后的补丁， 然后把这些补丁在 `master` 分支上重放一遍，让 `client` 看起来像直接基于 `master` 修改一样”。这理解起来有一点复杂，不过效果非常酷。
>
> ![从一个主题分支里再分出一个主题分支的提交历史。](images/interesting-rebase-1.png)
>
> ![截取主题分支上的另一个主题分支，然后变基到其他分支。](images/interesting-rebase-2.png)
>
> ```console
> $ git checkout master
> $ git merge client
> ```
>
> ![快进合并 `master` 分支，使之包含来自 `client` 分支的修改。](images/interesting-rebase-3.png)



### 服务器上的Git

#### 协议

> Git 可以使用四种不同的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git 协议

- **本地协议**

> *本地协议（Local protocol）* ，其中的远程版本库就是同一主机上的另一个目录。 
>
> **优点**
>
> 基于文件系统的版本库的优点是简单，并且直接使用了现有的文件权限和网络访问权限。 如果你的团队已经有共享文件系统，建立版本库会十分容易。 只需要像设置其他共享目录一样，把一个裸版本库的副本放到大家都可以访问的路径，并设置好读/写的权限，就可以了， 我们会在 [在服务器上搭建 Git](https://git-scm.com/book/zh/v2/ch00/_getting_git_on_a_server) 讨论如何导出一个裸版本库。
>
> 这也是快速从别人的工作目录中拉取更新的方法。 如果你和别人一起合作一个项目，他想让你从版本库中拉取更新时，运行类似 `git pull /home/john/project` 的命令比推送到服务器再抓取回来简单多了。
>
> ** 缺点**
>
> 这种方法的缺点是，通常共享文件系统比较难配置，并且比起基本的网络连接访问，这不方便从多个位置访问。 如果你想从家里推送内容，必须先挂载一个远程磁盘，相比网络连接的访问方式，配置不方便，速度也慢。
>
> 值得一提的是，如果你使用的是类似于共享挂载的文件系统时，这个方法不一定是最快的。 访问本地版本库的速度与你访问数据的速度是一样的。 在同一个服务器上，如果允许 Git 访问本地硬盘，一般的通过 NFS 访问版本库要比通过 SSH 访问慢。
>
> 最终，这个协议并不保护仓库避免意外的损坏。 每一个用户都有“远程”目录的完整 shell 权限，没有方法可以阻止他们修改或删除 Git 内部文件和损坏仓库。

- **HTTP协议**

> 智能 HTTP 的运行方式和 SSH 及 Git 协议类似，只是运行在标准的 HTTP/S 端口上并且可以使用各种 HTTP 验证机制， 这意味着使用起来会比 SSH 协议简单的多，比如可以使用 HTTP 协议的用户名/密码授权，免去设置 SSH 公钥
>
> **优点**
>
> 我们将只关注智能 HTTP 协议的优点。
>
> 不同的访问方式只需要一个 URL 以及服务器只在需要授权时提示输入授权信息，这两个简便性让终端用户使用 Git 变得非常简单。 相比 SSH 协议，可以使用用户名／密码授权是一个很大的优势，这样用户就不必须在使用 Git 之前先在本地生成 SSH 密钥对再把公钥上传到服务器。 对非资深的使用者，或者系统上缺少 SSH 相关程序的使用者，HTTP 协议的可用性是主要的优势。 与 SSH 协议类似，HTTP 协议也非常快和高效。
>
> 你也可以在 HTTPS 协议上提供只读版本库的服务，如此你在传输数据的时候就可以加密数据；或者，你甚至可以让客户端使用指定的 SSL 证书。
>
> 另一个好处是 HTTPS 协议被广泛使用，一般的企业防火墙都会允许这些端口的数据通过。
>
> **缺点**
>
> 在一些服务器上，架设 HTTPS 协议的服务端会比 SSH 协议的棘手一些。 除了这一点，用其他协议提供 Git 服务与智能 HTTP 协议相比就几乎没有优势了。
>
> 如果你在 HTTP 上使用需授权的推送，管理凭证会比使用 SSH 密钥认证麻烦一些。 然而，你可以选择使用凭证存储工具，比如 macOS 的 Keychain 或者 Windows 的凭证管理器。 参考 [凭证存储](https://git-scm.com/book/zh/v2/ch00/_credential_caching) 如何安全地保存 HTTP 密码。

- **SSH**

> 架设 Git 服务器时常用 SSH 协议作为传输协议。 因为大多数环境下服务器已经支持通过 SSH 访问 —— 即使没有也很容易架设。 SSH 协议也是一个验证授权的网络协议；并且，因为其普遍性，架设和使用都很容易。
>
> **优势**
>
> 用 SSH 协议的优势有很多。 首先，SSH 架设相对简单 —— SSH 守护进程很常见，多数管理员都有使用经验，并且多数操作系统都包含了它及相关的管理工具。 其次，通过 SSH 访问是安全的 —— 所有传输数据都要经过授权和加密。 最后，与 HTTPS 协议、Git 协议及本地协议一样，SSH 协议很高效，在传输前也会尽量压缩数据。
>
> **缺点**
>
> SSH 协议的缺点在于它不支持匿名访问 Git 仓库。 如果你使用 SSH，那么即便只是读取数据，使用者也 **必须** 通过 SSH 访问你的主机， 这使得 SSH 协议不利于开源的项目，毕竟人们可能只想把你的仓库克隆下来查看。 如果你只在公司网络使用，SSH 协议可能是你唯一要用到的协议。 如果你要同时提供匿名只读访问和 SSH 协议，那么你除了为自己推送架设 SSH 服务以外， 还得架设一个可以让其他人访问的服务。

- **Git协议**

>  这是包含在 Git 里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于 SSH 服务，但是访问无需任何授权。 要让版本库支持 Git 协议，需要先创建一个 `git-daemon-export-ok` 文件 —— 它是 Git 协议守护进程为这个版本库提供服务的必要条件 —— 但是除此之外没有任何安全措施。 要么谁都可以克隆这个版本库，要么谁也不能。 这意味着，通常不能通过 Git 协议推送。 由于没有授权机制，一旦你开放推送操作，意味着网络上知道这个项目 URL 的人都可以向项目推送数据。 不用说，极少会有人这么做。
>
> **优点**
>
> 目前，Git 协议是 Git 使用的网络传输协议里最快的。 如果你的项目有很大的访问量，或者你的项目很庞大并且不需要为写进行用户授权，架设 Git 守护进程来提供服务是不错的选择。 它使用与 SSH 相同的数据传输机制，但是省去了加密和授权的开销。
>
> **缺点**
>
> Git 协议缺点是缺乏授权机制。 把 Git 协议作为访问项目版本库的唯一手段是不可取的。 一般的做法里，会同时提供 SSH 或者 HTTPS 协议的访问服务，只让少数几个开发者有推送（写）权限，其他人通过 `git://` 访问只有读权限。 Git 协议也许也是最难架设的。 它要求有自己的守护进程，这就要配置 `xinetd`、`systemd` 或者其他的程序，这些工作并不简单。 它还要求防火墙开放 9418 端口，但是企业防火墙一般不会开放这个非标准端口。 而大型的企业防火墙通常会封锁这个端口。

### Git 内部原理

> https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E5%BA%95%E5%B1%82%E5%91%BD%E4%BB%A4%E4%B8%8E%E4%B8%8A%E5%B1%82%E5%91%BD%E4%BB%A4

#### 底层命令

> 当在一个新目录或已有目录执行 `git init` 时，Git 会创建一个 `.git` 目录。 这个目录包含了几乎所有 Git 存储和操作的东西。 如若想备份或复制一个版本库，只需把这个目录拷贝至另一处即可。 本章探讨的所有内容，均位于这个目录内。 新初始化的 `.git` 目录的典型结构如下：
>
> ```console
> $ ls -F1
> config
> description
> HEAD
> hooks/
> info/
> objects/
> refs/
> ```
>
> 随着 Git 版本的不同，该目录下可能还会包含其他内容。 不过对于一个全新的 `git init` 版本库，这将是你看到的默认结构。 `description` 文件仅供 GitWeb 程序使用，我们无需关心。 `config` 文件包含项目特有的配置选项。 `info` 目录包含一个全局性排除（global exclude）文件， 用以放置那些不希望被记录在 `.gitignore` 文件中的忽略模式（ignored patterns）。 `hooks` 目录包含客户端或服务端的钩子脚本（hook scripts）， 在 [Git 钩子](https://git-scm.com/book/zh/v2/ch00/_git_hooks) 中这部分话题已被详细探讨过。
>
> 剩下的四个条目很重要：`HEAD` 文件、（尚待创建的）`index` 文件，和 `objects` 目录、`refs` 目录。 它们都是 Git 的核心组成部分。 `objects` 目录存储所有数据内容；`refs` 目录存储指向数据（分支、远程仓库和标签等）的提交对象的指针； `HEAD` 文件指向目前被检出的分支；`index` 文件保存暂存区信息。




[^1]: 检验和([checksum](https://baike.baidu.com/item/checksum/1691589)):在数据处理和数据通信领域中，用于校验目的地一组[数据项](https://baike.baidu.com/item/数据项/3227309)的和。它通常是以十六进制为数制表示的形式。如果校验和的数值超过十六进制的FF，也就是255. 就要求其补码作为校验和。通常用来在通信中，尤其是远距离通信中保证数据的完整性和准确性。

[^2]:Git 仓库，在本文档中指的是本地仓库

### 参考资料

[pro git book](https://git-scm.com/book/en/v2)