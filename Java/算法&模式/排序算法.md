[toc]

### 算法特征

- **输入**：有0个或者多个输入，这些输入必须有清楚的描述和定义；
- **输出**：有1个或者多个输出结果，不可以没有输出结果；
- **有穷性(有限性)**：算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在有限的时间内完成；
- **确定性(明确性)**：算法每一步都有确定的含义，不会出现二义性；
- **可行性(有效性)**：算法的每一步都是清楚可行的，可以让用户用纸笔计算出结果；

> 满足确定性的算法也叫确定性算法；现在也拥有非确定性算法：如并行算法，概率算法等；

### 衡量排序算法的优劣

> 1. 时间复杂度：分析关键字的比较次数和记录的移动次数；
> 2. 空间复杂度：分析排序算法中需要多少内存；
> 3. 稳定性：若俩个记录A和B的关键字值相等，但排序后A和B的先后次序保持不变，则称这种排序算法是稳定的

### 排序算法分类

- **内部排序**

> 整个排序过程不需借助外部存储设备（如磁盘等），所有排序操作都在内存中进行

- **外部排序**

> 参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助外部存储器(如磁盘等)。常见的是多路归并排序，可以认为外部排序由多次内部排序组成。

### 十大内部排序算法

- **选择排序**

> 直接选择排序、堆排序

- **交换排序**

> 交换排序主要是通过排序表中俩个记录关键字的比较，若与排序要求相逆，则交换俩者顺序

> 冒泡排序、快速排序



- **插入排序**

> 直接插入排序、这班插入排序、shell排序

- **归并排序**

- **桶式排序**
- **基数排序**

#### 冒泡排序

> 冒泡排序的基本思想：通过对排序列表从前往后，依次比较相邻元素的排序码，若发现逆序则交换，使排序码较大的元素逐渐从前往后移

```
public static void main(String[] args) {
		int[] arr = new int[] { 1, 22, 33, 66, 22, 99, 32, 88 };
		for (int i = 0; i < arr.length - 1; i++) {
			for (int j = 0; j < arr.length - 1 - i; j++) {
				if (arr[j] > arr[j + 1]) {
					int tmp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = tmp;
				}
			}
		}
		
		for(int i=0;i<arr.length-1;i++) {
			System.out.println(arr[i]+",");
		}
	}
```

#### 快速排序

